Tree Traversals

Tree traversals help us visit all nodes of a tree in different sequences depending on the task or algorithm weâ€™re implementing.

1. âœ… Depth-First Traversal (DFT) (DFS- Depth First Search)
Inorder (Left â†’ Root â†’ Right) â†’ used in BST for sorted output

Preorder (Root â†’ Left â†’ Right) â†’ used for copying trees

Postorder (Left â†’ Right â†’ Root) â†’ used for deleting trees

ðŸŒ¿ 1. Inorder Traversal (Left â†’ Root â†’ Right)
âœ… Why it's used:
To get elements in sorted order from a Binary Search Tree (BST).

Useful for searching, displaying, or validating BST properties.

ðŸ§  Applications:
Printing BST in ascending order.

Checking whether a binary tree is a BST.

âœ… Example:
For a BST:

      10
     /  \
    5   20
âž¡ï¸ Inorder = 5 10 20 âœ… (sorted)

ðŸŒ± 2. Preorder Traversal (Root â†’ Left â†’ Right)
âœ… Why it's used:
To copy a tree structure (parent processed before children).

To serialize a tree (convert to storable form).

Useful in expression trees (prefix notation).

ðŸ§  Applications:
Tree cloning / copying.

Exporting or serializing a tree.

Prefix expression evaluation (e.g., +AB).

âœ… Example:
Same tree:


      10
     /  \
    5   20
âž¡ï¸ Preorder = 10 5 20

ðŸ‚ 3. Postorder Traversal (Left â†’ Right â†’ Root)
âœ… Why it's used:
To delete/free a tree bottom-up.

To evaluate postfix expressions (in expression trees).

Children are processed before parent.

ðŸ§  Applications:
Postfix evaluation (e.g., AB+).

Safely deleting nodes (memory cleanup).

Computing size/depth of a tree.

âœ… Example:

      10
     /  \
    5   20
âž¡ï¸ Postorder = 5 20 10

ðŸ“ Summary Table

Traversal		Order		Use Cases
Inorder		Left â†’ Root â†’ Right	Get sorted output from BST
Preorder	Root â†’ Left â†’ Right	Copy, serialize tree, prefix notation
Postorder	Left â†’ Right â†’ Root	Delete, evaluate postfix, free memory



POST-ORDER TRAVERSAL: left-->right-->root

void postorder(Node root) {
    if (root == null) return;

    postorder(root.left);   // Traverse left subtree
    postorder(root.right);  // Traverse right subtree
    System.out.print(root.data + " "); // Visit root
}


        10
       /  \
     5     15
    / \    /
   2   7  12

ðŸ” Postorder Traversal Visits:
Left subtree â†’ 2 â†’ 7 â†’ 5

Right subtree â†’ 12 â†’ 15

Root â†’ 10

âœ… Output: 2 7 5 12 15 10



PRE-ORDER TRAVERSAL: root-->left-->right

void preorder(Node root) {
    if (root == null) return;

    System.out.print(root.data + " "); // Visit root
    preorder(root.left);              // Traverse left subtree
    preorder(root.right);             // Traverse right subtree
}


        10
       /  \
     5     15
    / \    /
   2   7  12

Preorder Traversal would visit:
Root â†’ 10

Left Subtree â†’ 5 â†’ 2 â†’ 7

Right Subtree â†’ 15 â†’ 12

âœ… Output: 10 5 2 7 15 12



IN-ORDER TRAVERSAL: left-->root-->right

In a Binary Search Tree, inorder traversal gives elements in sorted order.
Useful for printing, validating, or extracting values from a BST.

        10
       /  \
      5    15
     / \     \
    2   7     20

âœ… Inorder Traversal Output:
2 5 7 10 15 20

void inorder(Node root) {
    if (root == null) return;

    inorder(root.left);          // 1. Visit left subtree
    System.out.print(root.data + " "); // 2. Visit root
    inorder(root.right);         // 3. Visit right subtree
}


Breadth-First Search(BFS):

BFS (Breadth-First Search) is a traversal algorithm that:
Explores level by level
Visits all neighbors before going deeper
Uses a queue to keep track of nodes to visit

âœ… Works for both:
Trees
Graphs

        1
       / \
      2   3
     / \   \
    4   5   6

ðŸ‘‰ BFS Traversal:
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6

ðŸ“¦ BFS Uses a Queue
âœ… BFS Algorithm (for Binary Tree):
1.Start with the root
2.Add it to a queue
3.While the queue is not empty:
	a.Remove the front node
	b.Process it
	c.Add its left and right children (if any) to the queue

void bfs(Node root) {
    if (root == null) return;

    Queue<Node> queue = new LinkedList<>();
    queue.add(root);

    while (!queue.isEmpty()) {
        Node current = queue.poll(); // remove front of queue
        System.out.print(current.data + " ");

        if (current.left != null)
            queue.add(current.left);
        if (current.right != null)
            queue.add(current.right);
    }
}





